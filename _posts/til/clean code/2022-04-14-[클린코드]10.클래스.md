---
title: "[클린코드]10.클래스"
categories:
  - TIL
tags:
  - TIL
  - Clean Code
  - Programming
---

## 📆TIL(Today I Learned) 날짜

2022.04.14

## 📑오늘 읽은 범위

10.클래스

## ✍🏻책에서 기억하고 싶은 내용

> 코드의 표현력과 그 코드로 이루어진 함수에 아무리 신경을 쓸지라도 좀 더 차원 높은 단계까지 신경 쓰지 않으면 꺠끗한 코드를 얻기는 어렵다.

> **클래스는 작아야 한다.**  
> "얼마나 작아야 하는가?" 함수는 물리적인 행 수로 크기를 측정했다. 클래스는 다른 척도를 사용한다. 클래스가 맡은 책임을 센다.

> 클래스 이름은 해당 클래스 책임을 기술해야 한다. 실제로 작명은 클래스 크기를 줄이는 첫 번째 관문이다. 간결한 이름이 떠오르지 않는다면 필경 클래스 크기가 너무 커서 그렇다. 클래스 이름이 모호하다면 필경 클래스 책임이 너무 많아서다.

> **단일 책임 원칙(Single Responsibility Principle, SRP)**  
> 단일 책임 원칙은 클래스나 모듈을 변경할 이유가 하나, 단 하나뿐이어야 한다는 원칙이다. (...) 클래스는 책임, 즉 변경할 이유가 하나여야 한다는 의미다.

> 문제는 우리들 대다수가 프로그램이 돌아가면 일이 끝났다고 여기는 데 있다. '깨끗하고 체계적인 소프트웨어'라는 다음 관심사로 전환하지 않는다. 프로그램으로 되돌아가 만능 클래스를 단일 책임 클래스 여럿으로 분리하는 대신 다음 문제로 넘어가버린다.

> 규모가 어느 수준에 이르는 시스템은 논리가 많고도 복잡하다. 이런 복잡성을 다루려면 체계적인 정리가 필수다. 그래야 개발자가 무엇이 어디에 있는지 쉽게 찾는다. 그래야 (변경을 가할 때) 직접 영향이 미치는 컴포넌트만 이해해도 충분하다.

> **응집도(Cohesion)**  
> 일반적으로 메서드가 변수를 더 많이 사용할수록 메서드와 클래스는 응집도가 더 높다. (...) 우리는 응집도가 높은 클래스를 선호한다. 응집도가 높다는 말은 클래스에 속한 메서드와 변수가 서로 의존하며 논리적인 단위로 묶인다는 의미기 때문이다.

> 응집도가 높아지도록 변수와 메서드를 적절히 분리해 새로운 클래스 두세 개로 쪼개준다.

> 클래스가 응집력을 잃는다면 쪼개라! 그래서 큰 함수를 작은 함수 여럿으로 쪼개다 보면 종종 작은 클래스 여럿으로 쪼갤 기회가 생긴다. 그러면서 프로그램에 점점 더 체계가 잡히고 구조가 투명해진다.

> **변경하기 쉬운 클래스**  
> 대다수 시스템은 지속적인 변경이 가해진다. 그리고 뭔가 변경할 때마다 시스템이 의도대로 동작하지 않을 위험이 따른다. 깨끗한 시스템은 클래스를 체계적으로 정리해 변경에 수반하는 위험을 낮춘다.

> 구체적인 클래스는 상세한 구현(코드)을 포함하며 추상 클래스는 개념만 포함한다고도 배웠다. 상세한 구현에 의존하는 클라이언트 클래스는 구현이 바뀌면 위험에 빠진다. 그래서 우리는 인터페이스와 추상 클래스를 사용해 구현이 미치는 영향을 격리한다.

> 결합도를 최소로 줄이면 자연스럽게 또 다른 클래스 설계 원칙인 DIP(Dependency Inversion Principle)를 따르는 클래스가 나온다. 본질적으로 DIP는 클래스가 상세한 구현이 아니라 추상화에 의존해야 한다는 원칙이다.

<br />

## ❗오늘 읽은 소감은?

- 예전에 한 번 《클린코드》를 읽은 후 코드 단위에서는 많은 것들을 실천하려고 노력했다. 하지만 클래스나 아키텍처 단위에서는 여전히 어려움을 느꼈고, 대부분 돌아가는데만 초점을 맞추었었다. 두 번째 읽는 것인데, 첫 번째 읽은 후와 똑같아서는 안 된다. 클래스 단위에서의 클린코드 작성도 노력해야 한다.

<br />

## ❓궁금한 내용, 잘 이해되지 않는 내용

- 클래스 설계 원칙 DIP(Dependency Inversion Principle)이란? 객체 지향 프로그래밍에서 의존관계 역전 원칙은 소프트웨어 모듈들을 분리하는 특정 형식을 지칭한다. 이 원칙을 따르면, 상위 계층(정책 결정)이 하위 계층(세부 사항)에 의존하는 전통적인 의존관계를 반전(역전)시킴으로써 상위 계층이 하위 계층의 구현으로부터 독립되게 할 수 있다. 이 원칙은 다음과 같은 내용을 담고 있다.

  > 첫째, 상위 모듈은 하위 모듈에 의존해서는 안 된다. 상위 모듈과 하위 모듈 모두 추상화에 의존해야 한다.  
  > 둘째, 추상화는 세부 사항에 의존해서는 안 된다. 세부사항이 추상화에 의존해야 한다.

  이 원칙은 '상위와 하위 객체 모두가 동일한 추상화에 의존해야 한다'는 객체 지향적 설계의 대원칙을 제공한다.
